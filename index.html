<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QVANTIK - Телеграм Миниприложение</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

    * {
      box-sizing: border-box;
    }

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Montserrat', sans-serif;
      background: #0d0f1a;
      color: #f0f0f5;
      overflow: hidden;
    }

    #workspace {
      height: 100vh;
      background: #0d0f1a;
      color: #e0f7fa;
      font-family: 'Montserrat', sans-serif;
      display: flex;
      justify-content: flex-start;
      align-items: flex-start;
      padding: 6px 8px 8px 8px;
      position: relative;
      user-select: none;
    }

    /* Container for the eyes in top-left corner */
    .eyes-container {
      display: flex;
      gap: 18px;
      width: 90px;
      height: 72px;
    }

    svg.eye-svg {
      width: 40px;
      height: 36px;
      overflow: visible;
    }

    /* Smaller rect eyes with glow */
    rect.eye-rect {
      fill: #4a6fff;
      rx: 10;
      ry: 10;
      filter: url(#glow);
      transition: all 0.2s ease;
    }
  </style>
</head>
<body>
  <div id="workspace" role="main" aria-label="Рабочее место QVANTIK миниприложения Телеграм">
    <div class="eyes-container" aria-label="Цифровые глаза робота Cozmo" role="img">
      <svg id="eye-left" class="eye-svg" viewBox="0 0 80 80" aria-label="Левый глаз" role="img" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="2" flood-color="#4a6fff" flood-opacity="0.6"/>
          </filter>
        </defs>
        <rect id="rect-left" class="eye-rect" x="5" y="18" width="34" height="34" />
      </svg>
      <svg id="eye-right" class="eye-svg" viewBox="0 0 80 80" aria-label="Правый глаз" role="img" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="2" flood-color="#4a6fff" flood-opacity="0.6"/>
          </filter>
        </defs>
        <rect id="rect-right" class="eye-rect" x="5" y="18" width="34" height="34" />
      </svg>
    </div>
  </div>

  <script>
    const rectLeft = document.getElementById('rect-left');
    const rectRight = document.getElementById('rect-right');

    const REF_EYE_WIDTH = 34;
    const REF_EYE_HEIGHT = 34;
    const REF_CORNER_RADIUS = 10;
    const REF_X = 5;
    const REF_Y = 18;

    let leftEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };
    let rightEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };

    function updateEye(rect, state) {
      rect.setAttribute('x', state.x);
      rect.setAttribute('y', state.y);
      rect.setAttribute('width', state.width);
      rect.setAttribute('height', state.height);
      rect.setAttribute('rx', state.rx);
      rect.setAttribute('ry', state.ry);
    }

    function resetEyes() {
      leftEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };
      rightEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };
      updateEye(rectLeft, leftEyeState);
      updateEye(rectRight, rightEyeState);
    }

    async function blink() {
      const steps = 6;
      for(let i=0; i<steps; i++) {
        leftEyeState.height -= REF_EYE_HEIGHT / steps;
        rightEyeState.height -= REF_EYE_HEIGHT / steps;
        leftEyeState.y += (REF_EYE_HEIGHT / steps) / 2;
        rightEyeState.y += (REF_EYE_HEIGHT / steps) / 2;
        leftEyeState.rx = Math.max(1, leftEyeState.height / 4);
        leftEyeState.ry = leftEyeState.rx;
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.rx;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      for(let i=0; i<steps; i++) {
        leftEyeState.height += REF_EYE_HEIGHT / steps;
        rightEyeState.height += REF_EYE_HEIGHT / steps;
        leftEyeState.y -= (REF_EYE_HEIGHT / steps) / 2;
        rightEyeState.y -= (REF_EYE_HEIGHT / steps) / 2;
        leftEyeState.rx = Math.min(REF_CORNER_RADIUS, leftEyeState.height / 4);
        leftEyeState.ry = leftEyeState.rx;
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.rx;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      resetEyes();
    }

    async function moveEyes(dx, dy, steps=10, delay=25) {
      for(let i=0; i<steps; i++) {
        leftEyeState.x += dx / steps;
        rightEyeState.x += dx / steps;
        leftEyeState.y += dy / steps;
        rightEyeState.y += dy / steps;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, delay));
      }
    }
    async function moveEyesBack(dx, dy, steps=10, delay=25) {
      for(let i=0; i<steps; i++) {
        leftEyeState.x -= dx / steps;
        rightEyeState.x -= dx / steps;
        leftEyeState.y -= dy / steps;
        rightEyeState.y -= dy / steps;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, delay));
      }
    }

    async function neutralExpression() {
      await new Promise(r => setTimeout(r, 1200));
    }

    async function happyExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<5; i++) {
        leftEyeState.rx = Math.max(4, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(4, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height -= 1.3;
        rightEyeState.height -= 1.3;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      await new Promise(r=>setTimeout(r, 500));
      for(let i=0; i<5; i++) {
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height += 1.3;
        rightEyeState.height += 1.3;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      resetEyes();
    }

    async function sadExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<5; i++) {
        leftEyeState.rx = Math.min(16, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(16, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height += 1.7;
        rightEyeState.height += 1.7;
        leftEyeState.y -= 0.4;
        rightEyeState.y -= 0.4;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      await new Promise(r=>setTimeout(r, 500));
      for(let i=0; i<5; i++) {
        leftEyeState.rx = Math.max(origLeft.rx, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(origLeft.ry, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height -= 1.7;
        rightEyeState.height -= 1.7;
        leftEyeState.y += 0.4;
        rightEyeState.y += 0.4;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      resetEyes();
    }

    async function surprisedExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<5; i++) {
        leftEyeState.width += 2;
        rightEyeState.width += 2;
        leftEyeState.height += 4;
        rightEyeState.height += 4;
        leftEyeState.rx = Math.max(1, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(1, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.x -= 1;
        rightEyeState.x -= 1;
        leftEyeState.y -= 2;
        rightEyeState.y -= 2;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      await new Promise(r=>setTimeout(r, 600));
      for(let i=0; i<5; i++) {
        leftEyeState.width -= 2;
        rightEyeState.width -= 2;
        leftEyeState.height -= 4;
        rightEyeState.height -= 4;
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.x += 1;
        rightEyeState.x += 1;
        leftEyeState.y += 2;
        rightEyeState.y += 2;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      resetEyes();
    }

    async function angryExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<5; i++) {
        leftEyeState.rx = Math.max(1, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(1, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height -= 1.5;
        rightEyeState.height -= 1.5;
        leftEyeState.y += 1.2;
        rightEyeState.y += 1.2;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      await new Promise(r=>setTimeout(r, 600));
      for(let i=0; i<5; i++) {
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height += 1.5;
        rightEyeState.height += 1.5;
        leftEyeState.y -= 1.2;
        rightEyeState.y -= 1.2;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 30));
      }
      resetEyes();
    }

    const expressions = [
      happyExpression,
      sadExpression,
      surprisedExpression,
      angryExpression,
      neutralExpression,
    ];

    function getRandomExpression() {
      return expressions[Math.floor(Math.random() * expressions.length)];
    }

    async function eyeAnimationLoop() {
      resetEyes();
      while(true) {
        const moves = [
          [5,0],[0,5],[-5,0],[0,-5],[5,5],[-5,5],[5,-5],[-5,-5],[0,0]
        ];
        const move = moves[Math.floor(Math.random() * moves.length)];
        await moveEyes(move[0], move[1]);
        await moveEyesBack(move[0], move[1]);

        await blink();

        const expr = getRandomExpression();
        await expr();
      }
    }

    function startEyeAnimation() {
      eyeAnimationLoop();
    }

    window.addEventListener('load', () => {
      startEyeAnimation();
    });
  </script>
</body>
</html>
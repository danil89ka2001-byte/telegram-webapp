<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QVANTIK - Телеграм Миниприложение</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

    * {
      box-sizing: border-box;
    }

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Montserrat', sans-serif;
      background: #0d0f1a;
      color: #f0f0f5;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #workspace {
      background: #0d0f1a;
      color: #e0f7fa;
      font-family: 'Montserrat', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      padding-left: 20px; /* немного левее, уменьшено */
    }

    /* Container for the eyes centered with adjusted size */
    .eyes-container {
      display: flex;
      gap: 50px; /* чуть меньше расстояния */
      width: 280px;
      height: 160px;
      position: relative;
    }

    svg.eye-svg {
      width: 140px;
      height: 140px;
      overflow: visible;
      box-sizing: content-box;
      padding: 12px; /* увеличен padding чтобы границы не заходили */
    }

    rect.eye-rect {
      fill: #4a6fff;
      rx: 25;  /* увеличен радиус скругления */
      ry: 25;
      filter: url(#glow);
      transition: all 0.2s ease;
    }

    path.heart {
      fill: #ff4d6d;
      filter: url(#glow);
      transform-origin: 50% 60%;
      transition: transform 0.3s ease;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="workspace" role="main" aria-label="Рабочее место QVANTIK миниприложения Телеграм">
    <div class="eyes-container" aria-label="Цифровые глаза робота Cozmo" role="img">
      <svg id="eye-left" class="eye-svg" viewBox="0 0 180 180" aria-label="Левый глаз" role="img" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="glow" x="-60%" y="-60%" width="220%" height="220%">
            <feDropShadow dx="0" dy="0" stdDeviation="8" flood-color="#4a6fff" flood-opacity="0.6"/>
          </filter>
        </defs>
        <rect id="rect-left" class="eye-rect" x="20" y="45" width="90" height="90" />
      </svg>
      <svg id="eye-right" class="eye-svg" viewBox="0 0 180 180" aria-label="Правый глаз" role="img" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="glow" x="-60%" y="-60%" width="220%" height="220%">
            <feDropShadow dx="0" dy="0" stdDeviation="8" flood-color="#4a6fff" flood-opacity="0.6"/>
          </filter>
        </defs>
        <rect id="rect-right" class="eye-rect" x="20" y="45" width="90" height="90" />
      </svg>
    </div>
  </div>

  <script>
    const rectLeft = document.getElementById('rect-left');
    const rectRight = document.getElementById('rect-right');
    const svgLeft = document.getElementById('eye-left');
    const svgRight = document.getElementById('eye-right');

    const REF_EYE_WIDTH = 90;
    const REF_EYE_HEIGHT = 90;
    const REF_CORNER_RADIUS = 25;
    const REF_X = 20;
    const REF_Y = 45;

    let leftEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };
    let rightEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };

    function updateEye(rect, state) {
      rect.setAttribute('x', state.x);
      rect.setAttribute('y', state.y);
      rect.setAttribute('width', state.width);
      rect.setAttribute('height', state.height);
      rect.setAttribute('rx', state.rx);
      rect.setAttribute('ry', state.ry);
    }

    function resetEyes() {
      leftEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };
      rightEyeState = { x: REF_X, y: REF_Y, width: REF_EYE_WIDTH, height: REF_EYE_HEIGHT, rx: REF_CORNER_RADIUS, ry: REF_CORNER_RADIUS };
      updateEye(rectLeft, leftEyeState);
      updateEye(rectRight, rightEyeState);
      removeHearts();
      rectLeft.style.display = '';
      rectRight.style.display = '';
      rectLeft.setAttribute('fill', '#4a6fff');
      rectRight.setAttribute('fill', '#4a6fff');
      rectLeft.setAttribute('filter', 'url(#glow)');
      rectRight.setAttribute('filter', 'url(#glow)');
    }

    async function blink() {
      const steps = 6;
      for(let i=0; i<steps; i++) {
        leftEyeState.height -= REF_EYE_HEIGHT / steps;
        rightEyeState.height -= REF_EYE_HEIGHT / steps;
        leftEyeState.y += (REF_EYE_HEIGHT / steps) / 2;
        rightEyeState.y += (REF_EYE_HEIGHT / steps) / 2;
        leftEyeState.rx = Math.max(1, leftEyeState.height / 4);
        leftEyeState.ry = leftEyeState.rx;
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.rx;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      for(let i=0; i<steps; i++) {
        leftEyeState.height += REF_EYE_HEIGHT / steps;
        rightEyeState.height += REF_EYE_HEIGHT / steps;
        leftEyeState.y -= (REF_EYE_HEIGHT / steps) / 2;
        rightEyeState.y -= (REF_EYE_HEIGHT / steps) / 2;
        leftEyeState.rx = Math.min(REF_CORNER_RADIUS, leftEyeState.height / 4);
        leftEyeState.ry = leftEyeState.rx;
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.rx;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }

    async function moveEyes(dx, dy, steps=10, delay=40) {
      for(let i=0; i<steps; i++) {
        leftEyeState.x += dx / steps;
        rightEyeState.x += dx / steps;
        leftEyeState.y += dy / steps;
        rightEyeState.y += dy / steps;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, delay));
      }
    }
    async function moveEyesBack(dx, dy, steps=10, delay=40) {
      for(let i=0; i<steps; i++) {
        leftEyeState.x -= dx / steps;
        rightEyeState.x -= dx / steps;
        leftEyeState.y -= dy / steps;
        rightEyeState.y -= dy / steps;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, delay));
      }
    }

    // Hearts management with rarer appearance
    let heartLeft = null;
    let heartRight = null;
    let loveExpressionCooldown = false;

    function createHeart(svg) {
      let heart = svg.querySelector('path.heart');
      if(heart) heart.remove();
      heart = document.createElementNS("http://www.w3.org/2000/svg", "path");
      heart.setAttribute('d', "M50 15 C35 0, 0 0, 0 37.5 C0 75, 50 90, 50 120 C50 90, 100 75, 100 37.5 C100 0, 65 0, 50 15 Z");
      heart.setAttribute('fill', '#ff4d6d');
      heart.setAttribute('filter', 'url(#glow)');
      heart.classList.add('heart');
      svg.appendChild(heart);
      heart.style.transformOrigin = '50% 60%';
      heart.style.transition = 'transform 0.3s ease';
      return heart;
    }

    function removeHearts() {
      if (heartLeft) {
        heartLeft.remove();
        heartLeft = null;
      }
      if (heartRight) {
        heartRight.remove();
        heartRight = null;
      }
    }

    async function loveExpression() {
      if (loveExpressionCooldown) return; // Prevent too frequent appearance
      loveExpressionCooldown = true;

      rectLeft.style.display = 'none';
      rectRight.style.display = 'none';

      heartLeft = createHeart(svgLeft);
      heartRight = createHeart(svgRight);

      const beatDuration = 700;
      let growing = true;
      let beats = 0;
      const maxBeats = 6;

      return new Promise((resolve) => {
        function beat() {
          if (beats >= maxBeats) {
            removeHearts();
            rectLeft.style.display = '';
            rectRight.style.display = '';
            resetEyes();
            resolve();
            setTimeout(() => { loveExpressionCooldown = false; }, 15000); // 15s cooldown
            return;
          }
          if (growing) {
            heartLeft.style.transform = 'scale(1.3)';
            heartRight.style.transform = 'scale(1.3)';
          } else {
            heartLeft.style.transform = 'scale(1)';
            heartRight.style.transform = 'scale(1)';
            beats++;
          }
          growing = !growing;
          setTimeout(beat, beatDuration);
        }
        beat();
      });
    }

    async function happyExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<10; i++) {
        leftEyeState.rx = Math.max(8, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(8, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height -= 3;
        rightEyeState.height -= 3;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      await new Promise(r=>setTimeout(r, 900));
      for(let i=0; i<10; i++) {
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height += 3;
        rightEyeState.height += 3;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }

    async function sadExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<10; i++) {
        leftEyeState.rx = Math.min(35, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(35, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height += 4;
        rightEyeState.height += 4;
        leftEyeState.y -= 1.5;
        rightEyeState.y -= 1.5;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      await new Promise(r=>setTimeout(r, 900));
      for(let i=0; i<10; i++) {
        leftEyeState.rx = Math.max(origLeft.rx, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(origLeft.ry, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height -= 4;
        rightEyeState.height -= 4;
        leftEyeState.y += 1.5;
        rightEyeState.y += 1.5;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }

    async function surprisedExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<10; i++) {
        leftEyeState.width += 7;
        rightEyeState.width += 7;
        leftEyeState.height += 14;
        rightEyeState.height += 14;
        leftEyeState.rx = Math.max(1, leftEyeState.rx - 3);
        leftEyeState.ry = Math.max(1, leftEyeState.ry - 3);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.x -= 3.5;
        rightEyeState.x -= 3.5;
        leftEyeState.y -= 7;
        rightEyeState.y -= 7;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      await new Promise(r=>setTimeout(r, 1100));
      for(let i=0; i<10; i++) {
        leftEyeState.width -= 7;
        rightEyeState.width -= 7;
        leftEyeState.height -= 14;
        rightEyeState.height -= 14;
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 3);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 3);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.x += 3.5;
        rightEyeState.x += 3.5;
        leftEyeState.y += 7;
        rightEyeState.y += 7;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }

    async function angryExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<10; i++) {
        leftEyeState.rx = Math.max(1, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(1, leftEyeState.ry - 2);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height -= 5;
        rightEyeState.height -= 5;
        leftEyeState.y += 4;
        rightEyeState.y += 4;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      await new Promise(r=>setTimeout(r, 1000));
      for(let i=0; i<10; i++) {
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 2);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.height += 5;
        rightEyeState.height += 5;
        leftEyeState.y -= 4;
        rightEyeState.y -= 4;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }
    
    // New expression: Fear (боязнь) - eyes shrink vertically and move slightly up
    async function fearExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<8; i++) {
        leftEyeState.height -= 6;
        rightEyeState.height -= 6;
        leftEyeState.y -= 3;
        rightEyeState.y -= 3;
        leftEyeState.rx = Math.max(5, leftEyeState.rx - 1);
        leftEyeState.ry = Math.max(5, leftEyeState.ry - 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      await new Promise(r => setTimeout(r, 900));
      for(let i=0; i<8; i++) {
        leftEyeState.height += 6;
        rightEyeState.height += 6;
        leftEyeState.y += 3;
        rightEyeState.y += 3;
        leftEyeState.rx = Math.min(origLeft.rx, leftEyeState.rx + 1);
        leftEyeState.ry = Math.min(origLeft.ry, leftEyeState.ry + 1);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }

    // New expression: Squint (прищуривание) - reduce width and increase rx/ry for sharper corners
    async function squintExpression() {
      const origLeft = {...leftEyeState};
      const origRight = {...rightEyeState};
      for(let i=0; i<8; i++) {
        leftEyeState.width -= 8;
        rightEyeState.width -= 8;
        leftEyeState.rx = Math.min(REF_CORNER_RADIUS + 15, leftEyeState.rx + 2);
        leftEyeState.ry = Math.min(REF_CORNER_RADIUS + 15, leftEyeState.ry + 2);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.x += 4;
        rightEyeState.x += 4;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      await new Promise(r => setTimeout(r, 900));
      for(let i=0; i<8; i++) {
        leftEyeState.width += 8;
        rightEyeState.width += 8;
        leftEyeState.rx = Math.max(REF_CORNER_RADIUS, leftEyeState.rx - 2);
        leftEyeState.ry = Math.max(REF_CORNER_RADIUS, leftEyeState.ry - 2);
        rightEyeState.rx = leftEyeState.rx;
        rightEyeState.ry = leftEyeState.ry;
        leftEyeState.x -= 4;
        rightEyeState.x -= 4;
        updateEye(rectLeft, leftEyeState);
        updateEye(rectRight, rightEyeState);
        await new Promise(r => setTimeout(r, 40));
      }
      resetEyes();
    }

    const expressions = [
      happyExpression,
      sadExpression,
      surprisedExpression,
      angryExpression,
      loveExpression,
      neutralExpression,
      fearExpression,
      squintExpression,
    ];

    function getRandomExpression() {
      // Make loveExpression rarer by filtering it out mostly
      let pool = expressions.filter(exp => exp !== loveExpression);
      if (Math.random() < 0.1) { // 10% chance loveExpression included
        pool.push(loveExpression);
      }
      return pool[Math.floor(Math.random() * pool.length)];
    }

    async function neutralExpression() {
      await new Promise(r => setTimeout(r, 1500));
    }

    async function eyeAnimationLoop() {
      resetEyes();
      while(true) {
        const moves = [
          [10,0],[0,10],[-10,0],[0,-10],[10,10],[-10,10],[10,-10],[-10,-10],[0,0]
        ];
        const move = moves[Math.floor(Math.random() * moves.length)];
        await moveEyes(move[0], move[1]);
        await moveEyesBack(move[0], move[1]);

        await blink();

        const expr = getRandomExpression();
        await expr();
      }
    }

    function startEyeAnimation() {
      eyeAnimationLoop();
    }

    window.addEventListener('load', () => {
      startEyeAnimation();
    });
  </script>
</body>
</html>